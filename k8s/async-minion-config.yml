kind: ConfigMap
apiVersion: v1
metadata:
  name: "{{name}}-async-minion-config"
  namespace: '{{ meta.namespace }}'
  labels:
    app: "{{name}}"
    container: async-minion
    group: microcks
data:
  application.properties: |-
    # Configuration file.
    %kube.quarkus.http.port=8080

    # Configure the log level.
    %kube.quarkus.log.level={{ microcks.log_level }}
    %kube.quarkus.log.console.level={{ microcks.log_level }}

    # Access to Microcks API server.
    %kube.io.github.microcks.minion.async.client.MicrocksAPIConnector/mp-rest/url=http://{{name}}:8080
    %kube.microcks.serviceaccount={{ keycloak.serviceAccount|default(keycloak.service_account) }}
    %kube.microcks.serviceaccount.credentials={{ keycloak.serviceAccountCredentials|default(keycloak.service_account_credentials) }}

    {% if keycloak.private_url is defined -%}
    # Access to Keycloak URL if you override the one coming from Microcks config
    keycloak.auth.url={{keycloak.private_url}}
    {% endif %}

    # Access to Kafka broker.
    {% if features.async.kafka.install -%}
    %kube.kafka.bootstrap.servers={{name}}-kafka-kafka-bootstrap:9092
    %kube.mp.messaging.incoming.microcks-services-updates.bootstrap.servers={{name}}-kafka-kafka-bootstrap:9092
    {% else -%}
    %kube.kafka.bootstrap.servers={{ features.async.kafka.url }}
    %kube.mp.messaging.incoming.microcks-services-updates.bootstrap.servers={{features.async.kafka.url}}

    {% if features.async.kafka.authentication.type == "SSL" -%}
    %kube.kafka.security.protocol=SSL
      {% if features.async.kafka.authentication.truststore_secret_ref is defined +%}
    %kube.kafka.ssl.truststore.location=/deployments/config/kafka/truststore/{{features.async.kafka.authentication.truststore_secret_ref.store_key}}
    %kube.kafka.ssl.truststore.password=${KAFKA_TRUSTSTORE_PASSWORD}
    %kube.kafka.ssl.truststore.type={{features.async.kafka.authentication.truststore_type}}
      {% endif +%}
    %kube.kafka.ssl.keystore.location=/deployments/config/kafka/keystore/{{features.async.kafka.authentication.keystore_secret_ref.store_key}}
    %kube.kafka.ssl.keystore.password=${KAFKA_KEYSTORE_PASSWORD}
    %kube.kafka.ssl.keystore.type={{features.async.kafka.authentication.keystore_type}}

    %kube.mp.messaging.incoming.microcks-services-updates.security.protocol=SSL
      {% if features.async.kafka.authentication.truststore_secret_ref is defined +%}
    %kube.mp.messaging.incoming.microcks-services-updates.ssl.truststore.location=/deployments/config/kafka/truststore/{{features.async.kafka.authentication.truststore_secret_ref.store_key}}
    %kube.mp.messaging.incoming.microcks-services-updates.ssl.truststore.password=${KAFKA_TRUSTSTORE_PASSWORD}
    %kube.mp.messaging.incoming.microcks-services-updates.ssl.truststore.type={{features.async.kafka.authentication.truststore_type}}
      {% endif +%}
    %kube.mp.messaging.incoming.microcks-services-updates.ssl.keystore.location=/deployments/config/kafka/keystore/{{features.async.kafka.authentication.keystore_secret_ref.store_key}}
    %kube.mp.messaging.incoming.microcks-services-updates.ssl.keystore.password=${KAFKA_KEYSTORE_PASSWORD}
    %kube.mp.messaging.incoming.microcks-services-updates.ssl.keystore.type={{features.async.kafka.authentication.keystore_type}}  
    {% elif features.async.kafka.authentication.type == "SASL_SSL" -%}
    %kube.kafka.security.protocol=SASL_SSL
      {% if features.async.kafka.authentication.truststore_secret_ref is defined +%}
    %kube.kafka.ssl.truststore.location=/deployments/config/kafka/truststore/{{features.async.kafka.authentication.truststore_secret_ref.store_key}}
    %kube.kafka.ssl.truststore.password=${KAFKA_TRUSTSTORE_PASSWORD}
    %kube.kafka.ssl.truststore.type={{features.async.kafka.authentication.truststore_type}}
      {% endif +%}
    %kube.kafka.sasl.mechanism={{features.async.kafka.authentication.sasl_mechanism}}
    %kube.kafka.sasl.jaas.config={{features.async.kafka.authentication.sasl_jaas_config}}

    %kube.mp.messaging.incoming.microcks-services-updates.security.protocol=SASL_SSL
      {% if features.async.kafka.authentication.truststore_secret_ref is defined +%}
    %kube.mp.messaging.incoming.microcks-services-updates.ssl.truststore.location=/deployments/config/kafka/truststore/{{features.async.kafka.authentication.truststore_secret_ref.store_key}}
    %kube.mp.messaging.incoming.microcks-services-updates.ssl.truststore.password=${KAFKA_TRUSTSTORE_PASSWORD}
    %kube.mp.messaging.incoming.microcks-services-updates.ssl.truststore.type={{features.async.kafka.authentication.truststore_type}}
      {% endif +%}
    %kube.mp.messaging.incoming.microcks-services-updates.sasl-mechanism={{features.async.kafka.authentication.sasl_mechanism}}
    %kube.mp.messaging.incoming.microcks-services-updates.sasl-jaas-config={{features.async.kafka.authentication.sasl_jaas_config}}
    {% endif %}
    {% endif %}

    {% if features.async.kafka.schema_registry.url is defined -%}
    # Access to Kafka schema registry.
    %kube.kafka.schema.registry.url={{ features.async.kafka.schema_registry.url }}
    %kube.kafka.schema.registry.confluent={{ features.async.kafka.schema_registry.confluent|lower }}
    %kube.kafka.schema.registry.username={{ features.async.kafka.schema_registry.username|default("") }}
    %kube.kafka.schema.registry.credentials.source={{ features.async.kafka.schema_registry.credentials_source }}
    {% endif %}

    # Access to MQTT broker.
    {% if features.async.mqtt.url is defined -%}
    %kube.mqtt.server={{ features.async.mqtt.url }}
    %kube.mqtt.username={{ features.async.mqtt.username }}
    %kube.mqtt.password={{ features.async.mqtt.password }}
    {% else -%}
    %kube.mqtt.server=localhost:1883
    %kube.mqtt.username=microcks
    %kube.mqtt.password=microcks
    {% endif %}

    # Configure the minion own behavioral properties.
    %kube.minion.supported-bindings=KAFKA,WS{% if features.async.mqtt.url is defined %},MQTT{% endif %}

    %kube.minion.restricted-frequencies=3,10,30
    %kube.minion.default-avro-encoding={{ features.async.default_avro_encoding }}